# Отчет по выполнению домашнего задания "Тема #21. Фильтрация и сортировка"

**Дата создания:** 2025-01-27  
**Статус:** ✅ Все требования выполнены

---

## Содержание

1. [Описание реализованного функционала](#1-описание-реализованного-функционала)
2. [Описание модификаций существующего кода](#2-описание-модификаций-существующего-кода)
3. [Пошаговые инструкции по использованию](#3-пошаговые-инструкции-по-использованию)
4. [Описание запросов к базе данных](#4-описание-запросов-к-базе-данных)
5. [Технические детали реализации](#5-технические-детали-реализации)
6. [Скриншоты работы функционала](#6-скриншоты-работы-функционала)

---

## 1. Описание реализованного функционала

### 1.1. Фильтрация товаров

Реализована возможность фильтрации товаров по следующим критериям:

#### ✅ Фильтрация по категории
- **Описание:** Пользователь может выбрать категорию товара из выпадающего списка
- **Реализация:** Используется ForeignKey связь между `Product` и `Category`
- **Поведение:** При выборе категории отображаются только товары из выбранной категории
- **Значение по умолчанию:** "Все категории" - отображаются все товары

#### ✅ Фильтрация по диапазону цен
- **Описание:** Пользователь может указать минимальную и/или максимальную цену товара
- **Реализация:** Используются поля `min_price` и `max_price` с фильтрацией через `price__gte` и `price__lte`
- **Поведение:** 
  - Если указана только минимальная цена - отображаются товары с ценой >= указанной
  - Если указана только максимальная цена - отображаются товары с ценой <= указанной
  - Если указаны обе цены - отображаются товары в указанном диапазоне
- **Валидация:** Поля принимают только числовые значения с шагом 0.01

#### ✅ Фильтрация по дате добавления
- **Описание:** Пользователь может выбрать период, за который были добавлены товары
- **Варианты фильтрации:**
  - **Все товары** - отображаются все товары без ограничения по дате
  - **За последние 7 дней** - товары, добавленные за последнюю неделю
  - **За последние 30 дней** - товары, добавленные за последний месяц
- **Реализация:** Используется фильтрация через `created_at__gte` с вычислением даты через `timezone.now() - timedelta(days=N)`

### 1.2. Сортировка товаров

Реализована возможность сортировки товаров по следующим критериям:

#### ✅ Сортировка по популярности
- **Описание:** Товары сортируются по количеству заказов (по убыванию)
- **Реализация:** Используется аннотация `Count('order_items')` для подсчёта количества заказов
- **Поведение:** Товары с наибольшим количеством заказов отображаются первыми

#### ✅ Сортировка по цене
- **По возрастанию:** Товары сортируются от дешёвых к дорогим
- **По убыванию:** Товары сортируются от дорогих к дешёвым
- **Реализация:** Используется `order_by('price')` или `order_by('-price')`

#### ✅ Сортировка по дате добавления
- **Старые сначала:** Товары сортируются от старых к новым
- **Новые сначала:** Товары сортируются от новых к старым (по умолчанию)
- **Реализация:** Используется `order_by('created_at')` или `order_by('-created_at')`

### 1.3. Пагинация результатов

#### ✅ Разбиение на страницы
- **Описание:** Товары разбиваются на страницы по 10 штук
- **Реализация:** Используется `Paginator` из Django с параметром `per_page=10`
- **Навигация:** 
  - Кнопка "Первая" - переход на первую страницу
  - Кнопка "Предыдущая" - переход на предыдущую страницу
  - Информация о текущей странице и общем количестве страниц
  - Кнопка "Следующая" - переход на следующую страницу
  - Кнопка "Последняя" - переход на последнюю страницу

#### ✅ Сохранение фильтров при пагинации
- **Описание:** При переключении страниц все применённые фильтры сохраняются
- **Реализация:** Параметры фильтрации добавляются в URL при переключении страниц

### 1.4. AJAX-подгрузка данных

#### ✅ Асинхронное обновление списка товаров
- **Описание:** При изменении фильтров или сортировки список товаров обновляется без перезагрузки страницы
- **Реализация:** Используется Fetch API для отправки AJAX-запросов
- **Преимущества:**
  - Быстрая работа интерфейса
  - Отсутствие мигания страницы
  - Современный пользовательский опыт

#### ✅ Индикатор загрузки
- **Описание:** При загрузке данных отображается индикатор загрузки
- **Реализация:** Блок с сообщением "Загрузка товаров..." показывается во время AJAX-запроса

#### ✅ Обновление URL
- **Описание:** URL обновляется при изменении фильтров без перезагрузки страницы
- **Реализация:** Используется `window.history.pushState()` для обновления URL
- **Преимущества:** Можно поделиться ссылкой с применёнными фильтрами

---

## 2. Описание модификаций существующего кода

### 2.1. Модификация `shop/views.py`

#### Изменения в функции `product_list()`

**Было:**
```python
def product_list(request):
    products = Product.objects.all()
    context = {
        'products': products,
        'page_title': 'Каталог товаров',
    }
    return render(request, 'shop/product_list.html', context)
```

**Стало:**
```python
def product_list(request):
    # Получение параметров фильтрации из GET-запроса
    category_id = request.GET.get('category', '')
    min_price = request.GET.get('min_price', '')
    max_price = request.GET.get('max_price', '')
    date_filter = request.GET.get('date_filter', 'all')
    sort = request.GET.get('sort', '-created_at')
    
    # Аннотация для подсчёта популярности
    products = Product.objects.select_related('category').annotate(
        order_count=Count('order_items')
    )
    
    # Применение фильтров
    # ... (код фильтрации)
    
    # Применение сортировки
    # ... (код сортировки)
    
    # Пагинация
    paginator = Paginator(products, 10)
    page_number = request.GET.get('page', 1)
    page_obj = paginator.get_page(page_number)
    
    # Проверка AJAX-запроса
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({...})
    
    # Обычный HTTP-запрос
    context = {...}
    return render(request, 'shop/product_list.html', context)
```

#### Добавленные импорты

```python
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.utils import timezone
from datetime import timedelta
from .models import Product, Message, Order, Cart, CartItem, Category
```

#### Ключевые изменения:

1. **Добавлена обработка параметров фильтрации:**
   - `category_id` - фильтрация по категории
   - `min_price` и `max_price` - фильтрация по цене
   - `date_filter` - фильтрация по дате добавления
   - `sort` - параметр сортировки

2. **Добавлена аннотация для популярности:**
   - Используется `annotate(order_count=Count('order_items'))` для подсчёта количества заказов

3. **Добавлена фильтрация:**
   - По категории: `products.filter(category_id=int(category_id))`
   - По цене: `products.filter(price__gte=float(min_price))` и `products.filter(price__lte=float(max_price))`
   - По дате: `products.filter(created_at__gte=timezone.now() - timedelta(days=N))`

4. **Добавлена сортировка:**
   - По популярности: `products.order_by('-order_count', '-created_at')`
   - По цене: `products.order_by('price')` или `products.order_by('-price')`
   - По дате: `products.order_by('created_at')` или `products.order_by('-created_at')`

5. **Добавлена пагинация:**
   - Используется `Paginator(products, 10)` для разбиения на страницы по 10 товаров

6. **Добавлена поддержка AJAX:**
   - Проверка заголовка `X-Requested-With: XMLHttpRequest`
   - Возврат JSON-ответа с данными товаров для AJAX-запросов

### 2.2. Модификация `templates/shop/product_list.html`

#### Добавленные элементы:

1. **Форма фильтрации:**
   - Выпадающий список категорий
   - Поля для минимальной и максимальной цены
   - Выпадающий список для фильтрации по дате
   - Выпадающий список для сортировки
   - Кнопки "Применить фильтры" и "Сбросить"

2. **Информация о результатах:**
   - Отображение количества найденных товаров
   - Информация о текущей странице

3. **Блок пагинации:**
   - Кнопки навигации по страницам
   - Информация о текущей странице и общем количестве страниц

4. **JavaScript-код для AJAX:**
   - Обработчик отправки формы
   - Функция отправки AJAX-запроса
   - Функция обновления списка товаров
   - Функция обновления пагинации
   - Функция обновления URL

#### Структура шаблона:

```html
{% extends "shop/base.html" %}
{% block content %}
    <!-- Заголовок -->
    <h1>Каталог товаров</h1>
    
    <!-- Форма фильтрации -->
    <form id="filter-form">
        <!-- Поля фильтрации -->
    </form>
    
    <!-- Информация о результатах -->
    <div class="results-info">...</div>
    
    <!-- Контейнер для товаров -->
    <div id="product-list-container">
        <!-- Сетка товаров -->
        <div class="products-grid" id="products-grid">
            <!-- Товары -->
        </div>
        
        <!-- Пагинация -->
        <div class="pagination">...</div>
    </div>
    
    <!-- Индикатор загрузки -->
    <div id="loading-indicator">...</div>
{% endblock %}

{% block extra_js %}
<script>
    // JavaScript-код для AJAX
</script>
{% endblock %}
```

### 2.3. Модификация `templates/shop/base.html`

#### Добавлен блок для дополнительных JavaScript:

```html
{% block extra_js %}
{% endblock %}
```

Этот блок позволяет дочерним шаблонам добавлять свой JavaScript-код без модификации базового шаблона.

### 2.4. Добавление стилей в `static/shop/css/styles.css`

#### Новые стили:

1. **Стили для формы фильтрации:**
   - `.filters-section` - контейнер формы фильтрации
   - `.filter-form` - форма фильтрации
   - `.filter-row` - строка с полями фильтрации
   - `.filter-group` - группа полей фильтрации
   - `.filter-select` и `.filter-input` - стили для полей ввода

2. **Стили для пагинации:**
   - `.pagination` - контейнер пагинации
   - `.pagination-link` - ссылки на страницы
   - `.pagination-info` - информация о текущей странице

3. **Стили для индикатора загрузки:**
   - `.loading-indicator` - индикатор загрузки

4. **Стили для отображения популярности:**
   - `.product-popularity` - отображение популярности товара
   - `.product-category` - отображение категории товара

5. **Адаптивные стили:**
   - Медиа-запросы для мобильных устройств

---

## 3. Пошаговые инструкции по использованию

### 3.1. Как использовать фильтры

#### Шаг 1: Открытие страницы каталога
1. Откройте браузер и перейдите на главную страницу сайта
2. Нажмите на ссылку "Каталог товаров" в меню навигации
3. Откроется страница со списком всех товаров

#### Шаг 2: Фильтрация по категории
1. В форме фильтрации найдите выпадающий список "Категория"
2. Выберите нужную категорию из списка
3. Нажмите кнопку "Применить фильтры"
4. Список товаров обновится автоматически (без перезагрузки страницы)
5. Отобразятся только товары из выбранной категории

#### Шаг 3: Фильтрация по цене
1. В форме фильтрации найдите поля "Мин. цена" и "Макс. цена"
2. Введите минимальную цену в поле "Мин. цена" (например, 100)
3. Введите максимальную цену в поле "Макс. цена" (например, 1000)
4. Нажмите кнопку "Применить фильтры"
5. Список товаров обновится автоматически
6. Отобразятся только товары в указанном диапазоне цен

**Примечание:** Можно указать только минимальную или только максимальную цену.

#### Шаг 4: Фильтрация по дате добавления
1. В форме фильтрации найдите выпадающий список "Дата добавления"
2. Выберите нужный период:
   - "Все товары" - отображаются все товары
   - "За последние 7 дней" - только товары, добавленные за последнюю неделю
   - "За последние 30 дней" - только товары, добавленные за последний месяц
3. Нажмите кнопку "Применить фильтры"
4. Список товаров обновится автоматически

#### Шаг 5: Комбинирование фильтров
1. Можно одновременно применять несколько фильтров
2. Например, выбрать категорию "Электроника", указать цену от 500 до 2000 рублей и выбрать "За последние 30 дней"
3. Нажмите кнопку "Применить фильтры"
4. Отобразятся товары, соответствующие всем выбранным критериям

#### Шаг 6: Сброс фильтров
1. Нажмите кнопку "Сбросить" в форме фильтрации
2. Все фильтры будут сброшены
3. Отобразятся все товары без фильтрации

### 3.2. Как использовать сортировку

#### Шаг 1: Выбор сортировки
1. В форме фильтрации найдите выпадающий список "Сортировка"
2. Выберите нужный вариант сортировки:
   - **По популярности** - товары с наибольшим количеством заказов первыми
   - **Цена (по возрастанию)** - от дешёвых к дорогим
   - **Цена (по убыванию)** - от дорогих к дешёвым
   - **Дата (старые сначала)** - от старых к новым
   - **Дата (новые сначала)** - от новых к старым (по умолчанию)
3. Нажмите кнопку "Применить фильтры"
4. Список товаров отсортируется согласно выбранному критерию

#### Шаг 2: Комбинирование сортировки с фильтрами
1. Можно одновременно применять фильтры и сортировку
2. Например, выбрать категорию "Одежда", указать цену до 5000 рублей и отсортировать по популярности
3. Нажмите кнопку "Применить фильтры"
4. Отобразятся отфильтрованные товары, отсортированные по популярности

### 3.3. Как использовать пагинацию

#### Шаг 1: Переключение страниц
1. Если товаров больше 10, внизу страницы появится блок пагинации
2. В блоке пагинации отображается информация: "Страница X из Y"
3. Для перехода на другую страницу используйте кнопки:
   - **"Первая"** - переход на первую страницу
   - **"Предыдущая"** - переход на предыдущую страницу
   - **"Следующая"** - переход на следующую страницу
   - **"Последняя"** - переход на последнюю страницу

#### Шаг 2: Сохранение фильтров при пагинации
1. При переключении страниц все применённые фильтры сохраняются
2. Например, если вы отфильтровали товары по категории "Электроника" и перешли на вторую страницу, фильтр по категории останется активным
3. Все товары на второй странице также будут из категории "Электроника"

### 3.4. Как работает AJAX

#### Автоматическое обновление
1. При изменении фильтров или сортировки список товаров обновляется автоматически
2. Страница не перезагружается полностью
3. Обновляется только блок со списком товаров
4. Во время загрузки отображается индикатор "Загрузка товаров..."

#### Обновление URL
1. При изменении фильтров URL в адресной строке браузера обновляется автоматически
2. Можно скопировать URL и поделиться им с другими пользователями
3. При открытии ссылки будут применены те же фильтры

#### Примеры URL:
- `/?category=1&min_price=100&max_price=1000&sort=popularity` - фильтрация по категории 1, цене от 100 до 1000 и сортировка по популярности
- `/?date_filter=7days&sort=-price` - товары за последние 7 дней, отсортированные по убыванию цены
- `/?page=2` - вторая страница со всеми товарами

---

## 4. Описание запросов к базе данных

### 4.1. Базовый запрос с аннотацией

#### Запрос для получения товаров с подсчётом популярности:

```python
products = Product.objects.select_related('category').annotate(
    order_count=Count('order_items')
)
```

**SQL-эквивалент:**
```sql
SELECT 
    shop_product.*,
    shop_category.*,
    COUNT(shop_orderitem.id) AS order_count
FROM shop_product
LEFT OUTER JOIN shop_category ON shop_product.category_id = shop_category.id
LEFT OUTER JOIN shop_orderitem ON shop_product.id = shop_orderitem.product_id
GROUP BY shop_product.id, shop_category.id;
```

**Описание:**
- Используется `select_related('category')` для оптимизации запроса к категории (один JOIN вместо N+1 запросов)
- Используется `annotate(order_count=Count('order_items'))` для подсчёта количества заказов каждого товара
- Результат группируется по товару, чтобы получить корректный подсчёт заказов

### 4.2. Запросы фильтрации

#### Фильтрация по категории:

```python
products = products.filter(category_id=int(category_id))
```

**SQL-эквивалент:**
```sql
WHERE shop_product.category_id = 1;
```

#### Фильтрация по минимальной цене:

```python
products = products.filter(price__gte=float(min_price))
```

**SQL-эквивалент:**
```sql
WHERE shop_product.price >= 100.00;
```

#### Фильтрация по максимальной цене:

```python
products = products.filter(price__lte=float(max_price))
```

**SQL-эквивалент:**
```sql
WHERE shop_product.price <= 1000.00;
```

#### Фильтрация по дате (последние 7 дней):

```python
seven_days_ago = timezone.now() - timedelta(days=7)
products = products.filter(created_at__gte=seven_days_ago)
```

**SQL-эквивалент:**
```sql
WHERE shop_product.created_at >= '2025-01-20 12:00:00';
```

#### Фильтрация по дате (последние 30 дней):

```python
thirty_days_ago = timezone.now() - timedelta(days=30)
products = products.filter(created_at__gte=thirty_days_ago)
```

**SQL-эквивалент:**
```sql
WHERE shop_product.created_at >= '2024-12-28 12:00:00';
```

### 4.3. Запросы сортировки

#### Сортировка по популярности:

```python
products = products.order_by('-order_count', '-created_at')
```

**SQL-эквивалент:**
```sql
ORDER BY order_count DESC, shop_product.created_at DESC;
```

**Описание:** Товары сортируются по убыванию количества заказов, при одинаковом количестве заказов - по дате создания (новые сначала).

#### Сортировка по цене (по возрастанию):

```python
products = products.order_by('price', '-created_at')
```

**SQL-эквивалент:**
```sql
ORDER BY shop_product.price ASC, shop_product.created_at DESC;
```

#### Сортировка по цене (по убыванию):

```python
products = products.order_by('-price', '-created_at')
```

**SQL-эквивалент:**
```sql
ORDER BY shop_product.price DESC, shop_product.created_at DESC;
```

#### Сортировка по дате (старые сначала):

```python
products = products.order_by('created_at')
```

**SQL-эквивалент:**
```sql
ORDER BY shop_product.created_at ASC;
```

#### Сортировка по дате (новые сначала):

```python
products = products.order_by('-created_at')
```

**SQL-эквивалент:**
```sql
ORDER BY shop_product.created_at DESC;
```

### 4.4. Комбинированный запрос с фильтрацией и сортировкой

#### Пример: Товары категории "Электроника", цена от 500 до 5000, за последние 30 дней, отсортированные по популярности

**Django ORM:**
```python
thirty_days_ago = timezone.now() - timedelta(days=30)
products = Product.objects.select_related('category').annotate(
    order_count=Count('order_items')
).filter(
    category_id=1,
    price__gte=500,
    price__lte=5000,
    created_at__gte=thirty_days_ago
).order_by('-order_count', '-created_at')
```

**SQL-эквивалент:**
```sql
SELECT 
    shop_product.*,
    shop_category.*,
    COUNT(shop_orderitem.id) AS order_count
FROM shop_product
LEFT OUTER JOIN shop_category ON shop_product.category_id = shop_category.id
LEFT OUTER JOIN shop_orderitem ON shop_product.id = shop_orderitem.product_id
WHERE shop_product.category_id = 1
  AND shop_product.price >= 500.00
  AND shop_product.price <= 5000.00
  AND shop_product.created_at >= '2024-12-28 12:00:00'
GROUP BY shop_product.id, shop_category.id
ORDER BY order_count DESC, shop_product.created_at DESC;
```

### 4.5. Запросы пагинации

#### Получение страницы товаров:

```python
paginator = Paginator(products, 10)
page_number = request.GET.get('page', 1)
page_obj = paginator.get_page(page_number)
```

**SQL-эквивалент (для первой страницы):**
```sql
-- Запрос для подсчёта общего количества
SELECT COUNT(*) FROM (
    -- основной запрос
) AS subquery;

-- Запрос для получения товаров на странице
-- (основной запрос)
LIMIT 10 OFFSET 0;
```

**SQL-эквивалент (для второй страницы):**
```sql
-- (основной запрос)
LIMIT 10 OFFSET 10;
```

**Описание:**
- `Paginator` автоматически выполняет два запроса:
  1. Запрос для подсчёта общего количества товаров
  2. Запрос для получения товаров на текущей странице с использованием `LIMIT` и `OFFSET`

### 4.6. Оптимизация запросов

#### Использование select_related():

```python
products = Product.objects.select_related('category')
```

**Преимущества:**
- Уменьшение количества запросов к базе данных
- Данные категории загружаются одним JOIN вместо N+1 запросов
- Улучшение производительности при большом количестве товаров

#### Использование annotate():

```python
products = products.annotate(order_count=Count('order_items'))
```

**Преимущества:**
- Подсчёт количества заказов выполняется на уровне базы данных
- Не требуется дополнительных запросов для каждого товара
- Эффективно даже при большом количестве товаров и заказов

---

## 5. Технические детали реализации

### 5.1. JavaScript-код для AJAX

#### Структура JavaScript-кода:

```javascript
(function() {
    'use strict';
    
    // Получение элементов DOM
    const filterForm = document.getElementById('filter-form');
    const productListContainer = document.getElementById('product-list-container');
    const loadingIndicator = document.getElementById('loading-indicator');
    
    // Функция для отправки AJAX-запроса
    function loadProducts(params) {
        // Показ индикатора загрузки
        loadingIndicator.style.display = 'block';
        
        // Формирование URL с параметрами
        const url = new URL(window.location.origin + window.location.pathname);
        Object.keys(params).forEach(key => {
            if (params[key]) {
                url.searchParams.set(key, params[key]);
            }
        });
        
        // Отправка AJAX-запроса
        fetch(url.toString(), {
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                updateProductList(data);
                updateResultsInfo(data);
                updatePagination(data, params);
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            window.location.href = url.toString();
        })
        .finally(() => {
            loadingIndicator.style.display = 'none';
        });
    }
    
    // Обработчик отправки формы
    filterForm.addEventListener('submit', function(e) {
        e.preventDefault();
        const params = getFormParams();
        updateURL(params);
        loadProducts(params);
    });
})();
```

#### Ключевые функции:

1. **`loadProducts(params)`** - отправка AJAX-запроса и обновление списка товаров
2. **`updateProductList(data)`** - обновление HTML-разметки списка товаров
3. **`updateResultsInfo(data)`** - обновление информации о количестве найденных товаров
4. **`updatePagination(data, params)`** - обновление блока пагинации
5. **`updateURL(params)`** - обновление URL без перезагрузки страницы
6. **`getFormParams()`** - получение параметров из формы фильтрации
7. **`escapeHtml(text)`** - экранирование HTML для безопасности

### 5.2. Обработка AJAX-запросов в Django

#### Проверка AJAX-запроса:

```python
if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
    # Это AJAX-запрос
    return JsonResponse({
        'success': True,
        'products': products_data,
        'has_next': page_obj.has_next(),
        'has_previous': page_obj.has_previous(),
        'current_page': page_obj.number,
        'total_pages': paginator.num_pages,
        'total_count': paginator.count,
    })
```

#### Формат JSON-ответа:

```json
{
    "success": true,
    "products": [
        {
            "id": 1,
            "name": "Товар 1",
            "price": "1000.00",
            "description": "Описание товара...",
            "image_url": "/media/products/image.jpg",
            "category": "Электроника",
            "created_at": "25.01.2025 14:30",
            "order_count": 5,
            "url": "/product/1/"
        },
        ...
    ],
    "has_next": true,
    "has_previous": false,
    "current_page": 1,
    "total_pages": 3,
    "total_count": 25
}
```

### 5.3. Обработка ошибок

#### В JavaScript:

```javascript
.catch(error => {
    console.error('Ошибка:', error);
    // При ошибке перезагружаем страницу обычным способом
    window.location.href = url.toString();
})
```

**Поведение:**
- При ошибке AJAX-запроса страница перезагружается обычным способом
- Пользователь видит результаты фильтрации, даже если AJAX не работает
- Обеспечивается обратная совместимость

#### В Django:

```python
try:
    products = products.filter(category_id=int(category_id))
except (ValueError, TypeError):
    pass  # Игнорируем неверные значения
```

**Поведение:**
- Неверные значения параметров игнорируются
- Запрос выполняется с остальными валидными параметрами
- Предотвращаются ошибки при некорректных данных

### 5.4. Безопасность

#### Экранирование HTML:

```javascript
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
```

**Защита от XSS:**
- Все данные из JSON экранируются перед вставкой в HTML
- Предотвращается выполнение вредоносного JavaScript-кода

#### Валидация параметров:

```python
try:
    products = products.filter(price__gte=float(min_price))
except (ValueError, TypeError):
    pass
```

**Защита от SQL-инъекций:**
- Django ORM автоматически экранирует параметры запросов
- Использование параметризованных запросов предотвращает SQL-инъекции

---

## 6. Скриншоты работы функционала

### 6.1. Страница каталога с фильтрами

**Описание:** Главная страница каталога товаров с формой фильтрации и сортировки.

**Что показано:**
- Форма фильтрации с полями:
  - Выпадающий список категорий
  - Поля для минимальной и максимальной цены
  - Выпадающий список для фильтрации по дате
  - Выпадающий список для сортировки
  - Кнопки "Применить фильтры" и "Сбросить"
- Список товаров в виде сетки
- Информация о количестве найденных товаров
- Блок пагинации (если товаров больше 10)

### 6.2. Результаты фильтрации

**Описание:** Страница с применёнными фильтрами.

**Что показано:**
- Выбранные фильтры в форме
- Отфильтрованный список товаров
- Информация о количестве найденных товаров
- Обновлённый URL в адресной строке браузера

### 6.3. Пагинация

**Описание:** Блок пагинации с кнопками навигации.

**Что показано:**
- Кнопки "Первая", "Предыдущая", "Следующая", "Последняя"
- Информация "Страница X из Y"
- Сохранение фильтров при переключении страниц

### 6.4. AJAX-обновление

**Описание:** Обновление списка товаров без перезагрузки страницы.

**Что показано:**
- Индикатор загрузки во время AJAX-запроса
- Плавное обновление списка товаров
- Обновление URL без перезагрузки страницы
- Отсутствие мигания страницы

### 6.5. Сортировка по популярности

**Описание:** Товары, отсортированные по количеству заказов.

**Что показано:**
- Товары с наибольшим количеством заказов отображаются первыми
- Для каждого товара отображается количество заказов
- Информация "Заказано раз: X"

### 6.6. Комбинированная фильтрация и сортировка

**Описание:** Применение нескольких фильтров одновременно.

**Что показано:**
- Выбранная категория
- Указанный диапазон цен
- Выбранный период даты
- Выбранная сортировка
- Результаты, соответствующие всем критериям

---

## Заключение

В рамках выполнения домашнего задания "Тема #21. Фильтрация и сортировка" были успешно реализованы:

1. ✅ **Фильтрация товаров** по категории, цене и дате добавления
2. ✅ **Сортировка товаров** по популярности, цене и дате
3. ✅ **Пагинация результатов** с отображением 10 товаров на странице
4. ✅ **AJAX-подгрузка данных** без перезагрузки страницы
5. ✅ **Полная документация** по всем аспектам реализации

Все требования выполнены, код протестирован и готов к использованию.

---

**Дата создания отчёта:** 2025-01-27  
**Версия:** 1.0  
**Статус:** ✅ Готово к сдаче

